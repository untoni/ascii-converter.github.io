<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title></title>

	<style>
		html {
			Access-Control-Allow-Origin: *;
		}
		section#main {
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
		}
		#image-input {
			display: none;
		}
		.input-label #upload-svg path {
			transition: all 0.5s ease;
		}
		.input-label:hover #upload-svg path {
			d: path('M34 38H41L51 46H3L13 38H20M27 41 37 31H31V15H23V31H17Z');
		}
		.input-label {
			display: flex;
			align-items: center;
			justify-content: center;
			width: 500px;
			height: 300px;
			border: 4px #112 dashed;
			border-radius: 5px;
			perspective: 100px;
		}
	</style>
</head>
<body>
	<section id="main">
		<label for="image-input" class="input-label">
			<div class="input-box">
				<input type="file" id="image-input" >
				<svg id='upload-svg' width="100" height="100" viewBox="0 0 55 55" stroke-width="2" fill="none" xmlns="http://www.w3.org/2000/svg">
					<path d="M26.5 36H41l10 12H3l10-12h14.5m-.5-3 10-10h-6V7h-8v16h-6z" stroke="#000" stroke-linecap="round" stroke-linejoin="round"/>
				</svg>
			</div>
		</label>
			<canvas id="canvas" style="image-rendering: pixelated;"></canvas>
		<pre id="result-ascii"></pre>
	</section>
</body>
</html>

<script>
	Element.prototype.hide = function() {
		this.style.display = 'none';
	};
	Element.prototype.show = function(display = 'block') {
		this.style.display = display;
	};
	const symbolsArray = [];
	const symbolW = 8;
	const symbolH = 16;

	function createASCIIsymbols(canvas) {
		const ascii = '!@%RO#$S?oi*`.:"\'()^v<>=-~_+ʃ|/\\ ░▒'; 

		canvas.width = ascii.length * 8.8;
		ctx.font = '16px monospace';
		ctx.fillStyle = '#000';    

		ctx.fillText(ascii, 0, 12);

		let maxSum = 0
		for(let i = 0; i < ascii.length; i++) {
			const symbolData = ctx.getImageData(i * 8.8+1, 0, symbolW, symbolH);
			const sum = 1 - imageSum(symbolData, 3);
			if(sum > maxSum) {
				maxSum = sum;
			}
			symbolData.sum = sum;
			symbolData.symbol = ascii[i]
			symbolsArray.push(symbolData);
		}

		for(let i = 0; i < symbolsArray.length; i++) {
			symbolsArray[i].sum /= maxSum;
		}
		console.log(symbolsArray)
	}

	function imageGrayFilter(imageData) {
		const data = imageData.data;
		const len = data.length;
		for(let i = 0; i < len; i += 4) {
			const gray = (data[i] + data[i + 1] + data[i + 2]) * 0.33;
			data[i] = gray;
			data[i + 1] = gray;
			data[i + 2] = gray;
			data[i + 3] = 255;
		}
		return imageData;
	}
	function imageSum(imageData, n) {
		const data = imageData.data
		let result = 0;
		for (let i = n; i < data.length; i += 4) {
			result += (255 - data[i]);
		}
		return result / (data.length * 64) 
	}

	function multiplyPixels(data1, data2) {
		const len = data1.length;
		let result = 0;
		for(let i = 2; i < len; i += 4) {
			result += (data1[i] - 128) * -(data2[i+1] - 128); 
		}
		return result;
	}

	function asciiConverterImage(imageData) {
		const data = imageData.data;
		const w = imageData.width;
		const h = imageData.height;

		for (let i = 0; i < h; i += symbolH) {
			for (let j = 0; j < w; j += symbolW) {
				const sliceData = ctx.getImageData(j, i, symbolW, symbolH);
				const sum = imageSum(sliceData, 0);
				let max = [-1, 0]
				for (let symbol = 0; symbol < symbolsArray.length; symbol++) {
					const symbolData = symbolsArray[symbol];
					let a = multiplyPixels(sliceData.data, symbolData.data);
					a += (1 - Math.abs(symbolData.sum - sum)) * 100000;					
					if(a > max[1] || max[0] < 0) {
						console.log(a)
						max[1] = a;
						max[0] = symbol;
					}
				}
				if(max[0] !== -1) {
					ctx.putImageData(symbolsArray[max[0]], j, i);
				}
			}
		}
	}
	function asciiConverterText(imageData) {
		const data = imageData.data;
		const w = imageData.width;
		const h = imageData.height;
		let resultText = '';

		for (let i = 0; i < h; i += symbolH) {
			for (let j = 0; j < w; j += symbolW) {
				const sliceData = ctx.getImageData(j, i, symbolW, symbolH);
				const sum = imageSum(sliceData, 0);
				let max = [-1, 0]

				for (let symbol = 0; symbol < symbolsArray.length; symbol++) {
					const symbolData = symbolsArray[symbol];
					let a = multiplyPixels(sliceData.data, symbolData.data);
					a *= (1 - Math.abs(symbolData.sum - sum));	

					if(a > max[1] || max[0] < 0) {
						max[1] = a;
						max[0] = symbol;
					}
				}
				if(max[0] !== -1) {
					resultText += symbolsArray[max[0]].symbol;
				}
			}
			resultText += '\n';
		}
		resultPre.innerText += resultText;
	}


	const canvas = document.getElementById('canvas');
	const ctx = canvas.getContext('2d');
	// canvas.hide();
	createASCIIsymbols(canvas);

	const inputLabel = document.querySelector('.input-label');
	const inputBox = inputLabel.querySelector('.input-box');
	const input = inputLabel.querySelector('#image-input');

	const resultPre = document.querySelector('pre#result-ascii');

	document.addEventListener('drop', (e) => {
		e.preventDefault();
		const item = e.dataTransfer.items[0];
		if (item.kind === 'file') {
			const file = item.getAsFile();
			handleImage(URL.createObjectURL(file));
		} else if (item.kind === 'string' && item.type === 'text/plain') {
			item.getAsString((url) => {
				handleImage(url);
			})
		}
	});
	window.addEventListener("dragover", (e) => {
		e.preventDefault();
	});
	window.addEventListener("drop", (e) => {
		e.preventDefault();
	});

	input.addEventListener('change', (e) => {
		const file = e.target.files[0]
		handleImage(URL.createObjectURL(file))
	});

	document.addEventListener('paste', async (e) => {
  		let item = e.clipboardData.items[0];

    		if (item.kind === "file") {
    			const file = item.getAsFile();
    			const url = URL.createObjectURL(file);
    			handleImage(url);
    		}

  		if (item.kind === "string" && item.type === "text/html") {
      			item.getAsString((html) => {
      				const match = html.match(/<img[^>]+src="([^">]+)"/);
      				if (match) {
					//console.log(match)
      					handleImage(match[1]);
      				}
      			});
		}
		if (item.kind === "string" && item.type === "text/plain") {
			item.getAsString((url) => {
				handleImage(url);
			})
		}
	})

	function handleImage(src) {
		const img = new Image();
		img.crossOrigin = "anonymous";
		img.onload = (e) => {
			inputLabel.hide();
			canvas.hide();
			canvas.width = img.width;
			canvas.height = img.height; 
			ctx.drawImage(img, 0, 0);
			const data = ctx.getImageData(0, 0, img.width, img.height);

			const newData = imageGrayFilter(data);
			ctx.putImageData(newData, 0, 0);
			asciiConverterText(newData);

		}
		img.src = src
	}


</script>
